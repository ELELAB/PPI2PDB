#!/usr/bin/env python3

# AGGREGATE
# Copyright (C) 2024  Eleni Kiachaki and Matteo Tiberti, Cancer Structural Biology, Danish Cancer Institute
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import argparse
import pandas as pd
import re

def main():
    parser = argparse.ArgumentParser(
        description="Aggregate results from mentha2pdb, string2pdb, pdbminer, and pdbminer_complexes.")

    parser.add_argument(
        "-m", 
        required=True,
        help="Path to the mentha2pdb output file. Expected file name: Uniprot_AC.csv.")

    parser.add_argument(
        "-s",
        required=True,
        help="Path to the string2pdb output file. Expected file name: Uniprot_AC_string_interactors.csv.")

    # parser.add_argument(
    #     "-p",
    #     required=True,
    #     help="Path to the pdbminer output file. Expected file name: Uniprot_AC_all.csv.")

    # parser.add_argument(
    #     "-pc",
    #     required=True,
    #     help="Path to the pdbminer_complexes output file. Expected file name: Uniprot_AC_filtered.csv.")

    args = parser.parse_args()

    # Load mentha2pdb output:
    mentha_df = pd.read_csv(args.m)

    # Load string2pdb output:
    string_df = pd.read_csv(args.s)

    
    ## MENTHA2PDB OUTPUT PRE-PROCESSING: ##

    if not mentha_df.empty:
    
        # Replace 'na' values with "":
        mentha_df.replace('na', "", inplace=True)

        # Keep only the required columns
        mentha_df = mentha_df[[
            "target uniprot id", 
            "target uniprot gene", 
            "interactor uniprot id", 
            "interactor uniprot gene", 
            "mentha score", 
            "PDB id", 
            "pDockQ HuMap", 
            "pDockQ HuRI"
        ]]

        # Simplify gene names by keeping only the part before the first space or '{' :
        # For cases like  MEOX2 {ECO:0000313|EMBL:CAG38790.1} or MEOX2{ECO:0000313|EMBL:CAG38790.1}
        mentha_df["target uniprot gene"] = mentha_df["target uniprot gene"].str.replace(r"[ {].*", "", regex=True)
        mentha_df["interactor uniprot gene"] = mentha_df["interactor uniprot gene"].str.replace(r"[ {].*", "", regex=True)

        # Initialize the "structure" column with the PDB id values:
        mentha_df["structure"] = mentha_df["PDB id"].fillna("")

        # Add "AF_Huri_HuMAP" to "structure" if HuMap or HuRI values are not "":
        mentha_df["structure"] = mentha_df.apply(
            lambda row: ",".join(filter(None, [row["structure"], "AF_Huri_HuMAP"])) \
            if row["pDockQ HuMap"] != "" or row["pDockQ HuRI"] != "" else row["structure"],
            axis=1
        )

        # Drop columns "PDB id", "pDockQ HuMap", and "pDockQ HuRI":
        mentha_df.drop(columns=["PDB id", "pDockQ HuMap", "pDockQ HuRI"], inplace=True)

         # Group by all columns except "structure" and aggregate "structure" as comma-separated strings
        mentha_df = mentha_df.groupby([
            "target uniprot id", 
            "target uniprot gene", 
            "interactor uniprot id", 
            "interactor uniprot gene", 
            "mentha score"
        ], as_index=False).agg({"structure": lambda x: ",".join(sorted(set(filter(None, x))))})

        mentha_df.sort_values(by="mentha score", ascending=False, inplace=True)


    ## STRING2PDB OUTPUT PRE-PROCESSING: ##

    if not string_df.empty:

        string_df.fillna("", inplace=True)

        # Keep only required columns from string_df:
        string_df = string_df[[
            "Target_protein", 
            "Target_Uniprot_AC", 
            "Interactor", 
            "Interactor_UniProt_AC", 
            "String_score", 
            "PDB_ID"
        ]]

        # Rename columns to match mentha for consistency:
        string_df.rename(columns={
            "Target_protein": "target uniprot gene",
            "Target_Uniprot_AC": "target uniprot id",
            "Interactor": "interactor uniprot gene",
            "Interactor_UniProt_AC": "interactor uniprot id",
            "String_score": "string score"
        }, inplace=True)

        # Group by relevant columns and aggregate PDB_IDs:
        string_df = string_df.groupby([
            "target uniprot gene", 
            "target uniprot id", 
            "interactor uniprot gene", 
            "interactor uniprot id", 
            "string score"
        ], as_index=False).agg({
        "PDB_ID": lambda x: ",".join(sorted(set(map(str, filter(None, x)))))
        })

        string_df.sort_values(by="string score", ascending=False, inplace=True)

    
    if not string_df.empty and not mentha_df.empty:

        mentha_target_id = mentha_df["target uniprot id"].iloc[0]
        string_target_id = string_df["target uniprot id"].iloc[0]
        if mentha_target_id != string_target_id:
            print(f"Error: Target Uniprot IDs do not match between mentha and string outputs.")
            exit(1)

        ## MERGING ##
        # Merge mentha_df and string_df:
        merged_df = pd.merge(
            mentha_df, 
            string_df[["interactor uniprot id", "PDB_ID", "string score"]], 
            on="interactor uniprot id", 
            how="left"
        )

        # Update structure column:
        merged_df["structure"] = merged_df.apply(
            lambda row: ",".join(filter(None, sorted(set(row["structure"].split(",") + row["PDB_ID"].split(",")))))
            if pd.notna(row["PDB_ID"]) else row["structure"],
            axis=1
        )
        
        # Drop unnecessary columns:
        merged_df.drop(columns=[ "PDB_ID"], inplace=True)

        merged_df.sort_values(by=["mentha score", "string score"], ascending=[False, False], inplace=True)

        # Find string entries not in mentha:
        unmatched_string_df = string_df[~string_df["interactor uniprot id"].isin(mentha_df["interactor uniprot id"])]
        unmatched_string_df = unmatched_string_df.rename(columns={"PDB_ID": "structure"})
        unmatched_string_df["mentha score"] = None
        unmatched_string_df = unmatched_string_df[[
            "target uniprot id", "target uniprot gene", "interactor uniprot id", 
            "interactor uniprot gene", "mentha score", "string score", "structure"
        ]]

        # Concatenate the unmatched string entries to df:
        final_df = pd.concat([merged_df, unmatched_string_df], ignore_index=True)

    elif mentha_df.empty and not string_df.empty:
        print(f"Warning: No results found in Mentha for the query protein")
        final_df = string_df
        # Add mentha score for consistency:
        final_df["mentha score"] = ""

    elif string_df.empty and not mentha_df.empty:
        print(f"Warning: No results found in STRING for the query protein")
        final_df = mentha_df
        # Add string score for consistency:
        final_df["string score"] = ""

    else:
        print(f"Warning:No results found in Mentha and STRING for the query protein")
        exit(0)

    # Add other resources column (where we will report pdbminer/pdbminer_complexes):
    final_df["other resources"] = ""

    # Ensure desired column order:
    final_columns = [
        "target uniprot id", 
        "target uniprot gene", 
        "interactor uniprot id", 
        "interactor uniprot gene", 
        "mentha score", 
        "string score", 
        "structure", 
        "other resources"
    ]

    final_df = final_df.reindex(columns=final_columns)

    filename = f"{final_df['target uniprot id'].iloc[0]}_aggregated.csv"
    final_df.to_csv(filename, index=False, na_rep="")
    print("Aggregation complete. Saved as", filename,".")

if __name__ == "__main__":
    main()

#!/usr/bin/env python3

# STRING2PDB
# Copyright (C) 2024  Eleni Kiachaki and Matteo Tiberti, Cancer Structural Biology, Danish Cancer Institute
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

import requests
import argparse
import pandas as pd
from io import StringIO
import re
import os

def gene2uniprot(genename):
    """
    Function: Gets all primary UniProt accessions for a given gene name,
    prioritizing entries where the parameter genename is the primary one.
    If no primary match is found, retrieve the primary accession of entries where the gene name is a synonym.
    
    Parameter:
        genename (str): Gene name to query.
        
    Returns:
        list: A list of primary UniProt accessions or 'None' if none found.
    """
    url = "https://rest.uniprot.org/uniprotkb/search"
    params = {
        "query": f"gene:{genename} AND organism_id:9606 AND reviewed:true",
        "format": "json",
    }

    try:
        response = requests.get(url, params=params)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"Error: Unable to fetch UniProt data for gene {genename} ({e})")
        exit(1)

    data = response.json()
    results = data.get("results", [])


    #Initialize accessions:
    primary_accessions = []
    fallback_accessions = []

    # Get gene information for every result:
    for entry in results:
        genes_info = entry.get("genes", [])

        is_primary = False
        for gene in genes_info:
            primary_gene = gene.get("geneName", {}).get("value", "")
            synonyms = [syn.get("value", "") for syn in gene.get("synonyms", [])]

            # Check if the parameter gene matches primary name:
            if primary_gene == genename:
                is_primary = True

                # Save the accession and move on to next entry:
                primary_accessions.append(entry["primaryAccession"])
                break

        # If not primary, add to fallback list:
        # Example where this was needed: Interactor P13385 of target P36896.
        if not is_primary:
            fallback_accessions.append(entry["primaryAccession"])

    # Return primary matches if found, otherwise return fallback matches:
    if primary_accessions:
        return primary_accessions
    elif fallback_accessions:
        print(f"Warning: No primary match found for {genename}. Returning fallback entries.")
        # Example where this was needed: Interactor P13385 of target P36896.
        return fallback_accessions
    else:
        # Example where this was needed: For the target P55211, the interactor with gene name: DIABLO-2
        # I do not know how to handle cases like this. Both DIABLO and DIABLO-2 are present in STRING database, but
        # the latter is not present in uniprot, so it cannot be mapped. Mentha does not return homologs that are not in Uniprot
        # So I thought that it would be okay to remove these cases from the results.
        print(f"Warning: No UniProt accessions found for gene {genename}, so it will be excluded from the results")
        return None



def main():
    parser = argparse.ArgumentParser(
        description="Retrieval of interaction data from the STRING database for a given gene name."
    )
    parser.add_argument(
        "identifier", 
        type=str,
        help="HUGO Gene name to retrieve interactors for."
    )
    parser.add_argument(
    "aliases_file_path", 
    type=str,
    nargs="?",
    default="/data/databases/STRING/9606.protein.aliases.v12.0.txt",
    help="Path to the aliases file. Default:/data/databases/STRING/9606.protein.aliases.v12.0.txt"
    )
    parser.add_argument(
        "-t", 
        "--threshold",
        type=float,
        default=0.7,
        help="Minimum STRING confidence score for interaction filtering (default: 0.7)."
    )
    parser.add_argument(
        "-n",
        "--network",
        type=str,
        default="physical",
        choices=["functional", "physical"],
        help="STRING network type to be used: 'physical' for physical interactions, 'functional' for all interactions (default: 'physical')."
    )

    args = parser.parse_args()

    
    base_url = "https://string-db.org/api/tsv/get_string_ids"
    params = {
        'identifier': args.identifier,  
        'species': 9606,         
        'limit': 0,  
        'caller_identity': "MAVISp_web_app"     
    }

    try:
        string_response = requests.get(base_url, params=params)
        string_response.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"Error: Unable to get data ({e})")
        exit(1)

    # Read tsv data into pandas dataframe:
    data = pd.read_csv(StringIO(string_response.text), sep='\t')

    # Convert each String_Id to UniProt AC and store in a new column:
    data['UniProt_AC'] = data['preferredName'].apply(gene2uniprot)

    # Explode the DataFrame for rows where UniProt_AC has multiple values:
    data = data.explode('UniProt_AC')

    # Check if identifier is in the converted UniProt_AC column:
    if args.identifier not in data['UniProt_AC'].values:
        print(f"Error: No STRING identifier found for {args.identifier} in the results.")
        exit(1)

    # Initialize matching_row to None:
    matching_row = None 

    # Check for multiple rows with different STRING IDs:
    unique_string_ids = data['stringId'].nunique()

    if unique_string_ids > 1:
        print(f"Warning: Multiple STRING IDs found for {args.identifier}. Proceeding with the String ID whose UniProt AC matches the input identifier:{args.identifier}.")
        # Select the row where UniProt_AC matches args.identifier
        matching_row = data[data['UniProt_AC'] == args.identifier]
        string_id = matching_row.iloc[0]['stringId']
            
    else:
        # Only one unique STRING ID, proceed with it:
        string_id = data.iloc[0]['stringId']

    # Get interactors from STRING API
    interactors_url = "https://string-db.org/api/tsv/interaction_partners"
    interactors_params = {
        'identifier': string_id,  
        'species': 9606,
        'required_score': args.threshold,
        'limit': 0,
        'network_type': args.network,
        'caller_identity': "MAVISp_web_app"
    }

    try:
        interactors_response = requests.get(interactors_url, params=interactors_params)
        interactors_response.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"Error: Unable to get interaction data ({e})")
        exit(1)

    # Read tsv data into pandas dataframe:
    interactors_df = pd.read_csv(StringIO(interactors_response.text), sep='\t')

    # Filter interactors with both score >= threshold and dscore > 0:
    # With database score > 0: No retrieval of unreviewed interactors
    filtered_interactors = interactors_df[(interactors_df['score'] >= args.threshold) & (interactors_df['dscore'] > 0)].copy()

    # Assign new columns:
    Interactor_UniProt_AC = []
    for name in filtered_interactors["preferredName_B"]:
        Interactor_UniProt_AC.append(gene2uniprot(name))

    # Add the Uniprot AC column:
    filtered_interactors["Interactor_UniProt_AC"] = Interactor_UniProt_AC

    # Remove rows where no UniProt accession was found for the genename: 
    filtered_interactors = filtered_interactors[filtered_interactors["Interactor_UniProt_AC"].notnull()]

    # Explode rows for multiple primary accessions:
    filtered_interactors = filtered_interactors.explode("Interactor_UniProt_AC")

    filtered_interactors['Target_Uniprot_AC'] = args.identifier

    if filtered_interactors.empty:
        print(f"No interactors found with score >= {args.threshold}.")
        exit(0)

    # Explode DataFrame for UniProt AC entries if multiple reviewed IDs found:
    filtered_interactors = filtered_interactors.explode('Interactor_UniProt_AC')

    # Extract columns:
    interactors = filtered_interactors[['preferredName_A', 'stringId_A', 'Target_Uniprot_AC', 'preferredName_B', 'stringId_B', 'Interactor_UniProt_AC',
                                        'score', 'escore', 'dscore', 'tscore']]

    # Output CSV file:
    output_file = f"{args.identifier}_string_interactors.csv"
    interactors.to_csv(output_file, index=False, header=['Target_protein', 'Target_id', 'Target_Uniprot_AC', 'Interactor', 'Interactor_id', 'Interactor_UniProt_AC',
                                                         'String_score', 'Experimental_score', 'Database_score', 
                                                         'Textmining_score'])

    print(f"Results saved to {output_file}")

if __name__ == "__main__":
    main()
